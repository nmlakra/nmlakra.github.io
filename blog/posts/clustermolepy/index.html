<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Clustermolepy | Nikhil Mark Lakra</title>
<meta name="keywords" content="single-cell, python">
<meta name="description" content="If you&rsquo;ve worked with single cell data, there is always one random cluster that refuses to be annotated. Which usually leads to a non-trivial amount of hours (if not days) spent on digging through cell marker databases and publications. When I came across the clustermole R package by Igor Dolgalev, I was pleasantly surprised at it effectiveness and simplicity. The only issue was that python is  my go to daily driver for most tasks; which also includes single cell analysis. So, I did the only logical thing anyone would; spend my next few weekends writing clustermolepy.">
<meta name="author" content="">
<link rel="canonical" href="http://nmlakra.github.io/posts/clustermolepy/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://nmlakra.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://nmlakra.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://nmlakra.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://nmlakra.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="http://nmlakra.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://nmlakra.github.io/posts/clustermolepy/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="http://nmlakra.github.io/posts/clustermolepy/">
  <meta property="og:site_name" content="Nikhil Mark Lakra">
  <meta property="og:title" content="Clustermolepy">
  <meta property="og:description" content="If you’ve worked with single cell data, there is always one random cluster that refuses to be annotated. Which usually leads to a non-trivial amount of hours (if not days) spent on digging through cell marker databases and publications. When I came across the clustermole R package by Igor Dolgalev, I was pleasantly surprised at it effectiveness and simplicity. The only issue was that python is my go to daily driver for most tasks; which also includes single cell analysis. So, I did the only logical thing anyone would; spend my next few weekends writing clustermolepy.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-04-05T12:49:40+05:30">
    <meta property="article:modified_time" content="2025-04-05T12:49:40+05:30">
    <meta property="article:tag" content="Single-Cell">
    <meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Clustermolepy">
<meta name="twitter:description" content="If you&rsquo;ve worked with single cell data, there is always one random cluster that refuses to be annotated. Which usually leads to a non-trivial amount of hours (if not days) spent on digging through cell marker databases and publications. When I came across the clustermole R package by Igor Dolgalev, I was pleasantly surprised at it effectiveness and simplicity. The only issue was that python is  my go to daily driver for most tasks; which also includes single cell analysis. So, I did the only logical thing anyone would; spend my next few weekends writing clustermolepy.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://nmlakra.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Clustermolepy",
      "item": "http://nmlakra.github.io/posts/clustermolepy/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Clustermolepy",
  "name": "Clustermolepy",
  "description": "If you\u0026rsquo;ve worked with single cell data, there is always one random cluster that refuses to be annotated. Which usually leads to a non-trivial amount of hours (if not days) spent on digging through cell marker databases and publications. When I came across the clustermole R package by Igor Dolgalev, I was pleasantly surprised at it effectiveness and simplicity. The only issue was that python is my go to daily driver for most tasks; which also includes single cell analysis. So, I did the only logical thing anyone would; spend my next few weekends writing clustermolepy.\n",
  "keywords": [
    "single-cell", "python"
  ],
  "articleBody": "If you’ve worked with single cell data, there is always one random cluster that refuses to be annotated. Which usually leads to a non-trivial amount of hours (if not days) spent on digging through cell marker databases and publications. When I came across the clustermole R package by Igor Dolgalev, I was pleasantly surprised at it effectiveness and simplicity. The only issue was that python is my go to daily driver for most tasks; which also includes single cell analysis. So, I did the only logical thing anyone would; spend my next few weekends writing clustermolepy.\nExample Usage Now, clustermolepy isn’t ment to be an automated cell type annotation tool, but a quick way to explore enrichment of marker genes from different annotation databases. Here’s an example of the main usecase, we’ll be using the pbmc3k dataset from scanpy for this following example.\nFirst, we need to install clustermolepy, which can be done using pip using:\npip install git+https://github.com/nmlakra/clustermole-py.git Next we can import scanpy and clustermolepy and setup our data for this example:\nCode:\n# Loading Enricher module from clustermolepy along with scanpy from clustermolepy.enrichr import Enrichr import scanpy as sc # Reading the pbmc3k data adata = sc.datasets.pbmc3k_processed() # Running the leiden clustering on adata sc.tl.leiden(adata, flavor='igraph', n_iterations=2, resolution=0.8) # Plotting the UMAP plots with orginal cell types present in the louvain column # the newly assigned cluster ids are present in the leiden column sc.pl.umap(adata, color=['louvain', 'leiden'], legend_loc='on data', save=\"pbmc3k_leiden.png\") Ouput: Identify Cluster DE Gene for Enricher We need to identify marker genes for each Leiden cluster. We’ll use Scanpy’s rank_genes_groups function to perform differential gene expression and find genes that are upregulated in each cluster compared to the others. clustermolepy provides a wrapper around Enrichr API to find enrichment of genes in gene sets.\nWe will use B cells for this example, which is a well defined population in pbmc3k dataset. Using scanpy.rank_gene_groups we can identifity the top 25 up-regulated genes in each cluster\nCode:\nsc.tl.rank_genes_groups(adata, 'leiden', method='wilcoxon', use_raw=False) # Let's extract the top N marker genes per cluster (e.g., top 25) top_n_markers = 25 b_cell_markers = sc.get.rank_genes_groups_df(adata, '1').head(top_n_markers).names # The Leiden Cluster 1 corresponds to B cells print(f\"Cluster Marker Genes (Top {top_n_markers} cluster_1 / B cells markers):\") print(b_cell_markers) Output:\nCluster Marker Genes (Top 25 cluster_1 / B cells markers): 0 HLA-DQA1 1 CD79A 2 HLA-DPB1 3 HLA-DRB1 4 HLA-DQB1 5 CD79B 6 HLA-DPA1 7 CD37 8 MS4A1 9 HLA-DMA 10 TCL1A 11 HLA-DMB 12 SMIM14 13 MZB1 14 LTB 15 PLD4 16 IGJ 17 EAF2 18 CD1C 19 RABEP2 20 TNFRSF17 21 RPL22L1 22 IRF8 23 CEPT1 24 NT5C Name: names, dtype: object Using the Enrichr Module for querying Enrichr libraries Now that we have our list of marker genes for each Leiden cluster, we can use clustermolepy’s built-in Enrichr module to directly query the Enrichr API! This makes it super easy to get biological insights from our marker genes.\nclustermolepy provides the get_cell_type_enrichment() method! This handy function simplifies the process by automatically querying a curated set of Enrichr libraries that are specifically relevant for cell type identification.\nUnder the hood, get_cell_type_enrichment() is multi-threaded, making it efficient forquerying multiple gene sets efficently. It automatically checks your marker genes against these ten key gene set libraries:\n* CellMarker_2024 * CellMarker_Augmented_2021 * Descartes_Cell_Types_and_Tissue_2021 * PanglaoDB_Augmented_2021 * Azimuth_Cell_Types_2021 * Azimuth_2023 * Tabula_Sapiens * Human_Gene_Atlas * Tabula_Muris * Mouse_Gene_Atlas Using get_cell_type_enrichment() is incredibly straightforward. Using this with our Leiden Cluster 1 marker genes:\nCode:\nenrichr = Enrichr(list(b_cell_markers), adj_pval_cutoff=0.05) enrichr.get_cell_type_enrichment().head() Output:\nterm name p-value odds ratio combined score overlapping genes adjusted p-value old p-value old adjusted p-value gene_set 0 B cell:Kidney 5.086026e-18 103.437309 4118.877258 [SMIM14, EAF2, CD79B, CD79A, TCL1A, RABEP2, MZB1, TNFRSF17, IRF8, CD37, RPL22L1, LTB, CEPT1, MS4A1] 8.544523e-16 0 0 CellMarker_Augmented_2021 1 B Cell Kidney Human 4.980387e-18 103.601072 4127.572795 [SMIM14, EAF2, CD79B, CD79A, TCL1A, RABEP2, MZB1, TNFRSF17, IRF8, CD37, RPL22L1, LTB, CEPT1, MS4A1] 9.213717e-16 0 0 CellMarker_2024 2 B Cell Lung Human 1.924020e-16 1664.666667 60239.200656 [CD79B, CD79A, TCL1A, MZB1, TNFRSF17, MS4A1] 1.779719e-14 0 0 CellMarker_2024 3 B Cells Naive 2.872640e-15 139.718310 4678.264291 [CD79B, CD79A, TCL1A, EAF2, IRF8, CD37, LTB, CD1C, MS4A1] 2.872640e-14 0 0 PanglaoDB_Augmented_2021 4 B Cells Memory 2.244502e-15 143.797101 4850.318315 [CD79B, CD79A, TCL1A, TNFRSF17, IRF8, CD37, LTB, CD1C, MS4A1] 2.872640e-14 0 0 PanglaoDB_Augmented_2021 How Does Enrichment Work? It’s worth briefly mentioning how the enrichment is actually calculated under the hood. At the core of this is a statistical test that checks whether your list of marker genes overlaps with known cell type–specific gene sets more than you’d expect by random chance.\nThis is done using Fisher’s exact test, which builds a simple 2×2 contingency table like this:\nFrom this table, Fisher’s Exact Test is used to calculate a p-value; basically asking: If I randomly picked genes, what’s the chance I’d see this much overlap?\nHere’s the formula behind it:\n$$ p = \\frac{{\\binom{a + b}{a} \\binom{c + d}{c}}}{{\\binom{N}{a + c}}} $$ Extra Utilities Beyond just sending your marker genes to Enrichr, clustermolepy comes with a couple of neat utilities that make your life easier when working with gene sets.\nFuzzy Matching for Enrichr Libraries If you’ve ever used the Enrichr web interface, you know how long list of libraries are. clustermolepy adds a small but super helpful feature: fuzzy matching for library names. So if you forget whether it’s called \"CellMarker_2024\" or \"cell_marker_human_2023\", you can just pass a partial name and let the fuzzy match do the work:\nCode:\nenrichr.get_libraries(name=\"cellmarker\") # fuzzy search! Output:\ngeneCoverage genesPerTerm libraryName link numTerms categoryId 0 14167 80.0 CellMarker_Augmented_2021 http://biocc.hrbmu.edu.cn/CellMarker/ 1097 5 1 12642 30.0 CellMarker_2024 http://bio-bigdata.hrbmu.edu.cn/CellMarker/ 1692 5 Gene Name Conversion via Biomart clustermolepy also provides a convenient way to convert gene symbols between different species using the biomart module. This is particularly useful when you want to compare gene sets or perform enrichment analysis across different organisms. In this example, we’ll convert human gene symbols to mouse gene symbols using the biomart module. We’ll use the convert_gene_names() function to fetch the gene conversion data and then apply it to our list of human genes.\nCode:\nfrom clustermolepy.utils import Biomart # Convert gene names from human to mouse bm = Biomart(verbose=False) result = bm.convert_gene_names( genes=[\"TP53\", \"CD4\", \"FOXP3\"], # Example gene names from_organism=\"hsapiens\", # Human to_organism=\"mmusculus\" # Mouse ) print(result) Output:\n{'CD4': ['Cd4'], 'FOXP3': ['Foxp3'], 'TP53': ['Trp53']} ",
  "wordCount" : "1044",
  "inLanguage": "en",
  "datePublished": "2025-04-05T12:49:40+05:30",
  "dateModified": "2025-04-05T12:49:40+05:30",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://nmlakra.github.io/posts/clustermolepy/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Nikhil Mark Lakra",
    "logo": {
      "@type": "ImageObject",
      "url": "http://nmlakra.github.io/favicon.ico"
    }
  }
}
</script>
    
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath: [['\\(', '\\)']]                  
    },
    loader:{
      load: ['ui/safe']
    },
  };
</script>

    
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://nmlakra.github.io/" accesskey="h" title="Nikhil Mark Lakra (Alt + H)">Nikhil Mark Lakra</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://nmlakra.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Clustermolepy
    </h1>
    <div class="post-meta"><span title='2025-04-05 12:49:40 +0530 IST'>April 5, 2025</span>&nbsp;·&nbsp;5 min

</div>
  </header> 
  <div class="post-content"><p>If you&rsquo;ve worked with single cell data, there is always one random cluster that refuses to be annotated. Which usually leads to a non-trivial amount of hours (if not days) spent on digging through cell marker databases and publications. When I came across the <a href="https://igordot.github.io/clustermole/">clustermole R package by Igor Dolgalev</a>, I was pleasantly surprised at it effectiveness and simplicity. The only issue was that python is  my go to daily driver for most tasks; which also includes single cell analysis. So, I did the only logical thing anyone would; spend my next few weekends writing <code>clustermolepy</code>.</p>
<h2 id="example-usage">Example Usage<a hidden class="anchor" aria-hidden="true" href="#example-usage">#</a></h2>
<p>Now, <code>clustermolepy</code> isn&rsquo;t ment to be an automated cell type annotation tool, but a quick way to explore enrichment of marker genes from different annotation databases. Here&rsquo;s an example of the main usecase, we&rsquo;ll be using the pbmc3k dataset from scanpy for this following example.</p>
<p>First, we need to install clustermolepy, which can be done using pip using:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>pip install git+https://github.com/nmlakra/clustermole-py.git
</span></span></code></pre></div><p>Next we can import <code>scanpy</code> and <code>clustermolepy</code> and setup our data for this example:</p>
<p><strong>Code:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Loading Enricher module from clustermolepy along with scanpy</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> clustermolepy.enrichr <span style="color:#f92672">import</span> Enrichr
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> scanpy <span style="color:#66d9ef">as</span> sc
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Reading the pbmc3k data</span>
</span></span><span style="display:flex;"><span>adata <span style="color:#f92672">=</span> sc<span style="color:#f92672">.</span>datasets<span style="color:#f92672">.</span>pbmc3k_processed()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Running the leiden clustering on adata</span>
</span></span><span style="display:flex;"><span>sc<span style="color:#f92672">.</span>tl<span style="color:#f92672">.</span>leiden(adata, flavor<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;igraph&#39;</span>, n_iterations<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, resolution<span style="color:#f92672">=</span><span style="color:#ae81ff">0.8</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Plotting the UMAP plots with orginal cell types present in the louvain column</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># the newly assigned cluster ids are present in the leiden column</span>
</span></span><span style="display:flex;"><span>sc<span style="color:#f92672">.</span>pl<span style="color:#f92672">.</span>umap(adata, color<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#39;louvain&#39;</span>, <span style="color:#e6db74">&#39;leiden&#39;</span>], legend_loc<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;on data&#39;</span>, save<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;pbmc3k_leiden.png&#34;</span>)
</span></span></code></pre></div><p><strong>Ouput:</strong>
<img alt="PBMC 3K UMAP" loading="lazy" src="/posts/clustermolepy/pbmc3k_umap.png"></p>
<h3 id="identify-cluster-de-gene-for-enricher">Identify Cluster DE Gene for Enricher<a hidden class="anchor" aria-hidden="true" href="#identify-cluster-de-gene-for-enricher">#</a></h3>
<p>We need to identify marker genes for each Leiden cluster. We&rsquo;ll use Scanpy&rsquo;s <code>rank_genes_groups</code> function to perform differential gene expression and find genes that are upregulated in each cluster compared to the others. <code>clustermolepy</code> provides a wrapper around Enrichr API to find enrichment of genes in gene sets.</p>
<p>We will use B cells for this example, which is a well defined population in pbmc3k dataset. Using <code>scanpy.rank_gene_groups</code> we can identifity the top 25 up-regulated genes in each cluster</p>
<p><strong>Code:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>sc<span style="color:#f92672">.</span>tl<span style="color:#f92672">.</span>rank_genes_groups(adata, <span style="color:#e6db74">&#39;leiden&#39;</span>, method<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;wilcoxon&#39;</span>, use_raw<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Let&#39;s extract the top N marker genes per cluster (e.g., top 25)</span>
</span></span><span style="display:flex;"><span>top_n_markers <span style="color:#f92672">=</span> <span style="color:#ae81ff">25</span>
</span></span><span style="display:flex;"><span>b_cell_markers <span style="color:#f92672">=</span> sc<span style="color:#f92672">.</span>get<span style="color:#f92672">.</span>rank_genes_groups_df(adata, <span style="color:#e6db74">&#39;1&#39;</span>)<span style="color:#f92672">.</span>head(top_n_markers)<span style="color:#f92672">.</span>names <span style="color:#75715e"># The Leiden Cluster 1 corresponds to B cells</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Cluster Marker Genes (Top </span><span style="color:#e6db74">{</span>top_n_markers<span style="color:#e6db74">}</span><span style="color:#e6db74"> cluster_1 / B cells markers):&#34;</span>)
</span></span><span style="display:flex;"><span>print(b_cell_markers)
</span></span></code></pre></div><p><strong>Output:</strong></p>
<pre tabindex="0"><code>Cluster Marker Genes (Top 25 cluster_1 / B cells markers):
0     HLA-DQA1
1        CD79A
2     HLA-DPB1
3     HLA-DRB1
4     HLA-DQB1
5        CD79B
6     HLA-DPA1
7         CD37
8        MS4A1
9      HLA-DMA
10       TCL1A
11     HLA-DMB
12      SMIM14
13        MZB1
14         LTB
15        PLD4
16         IGJ
17        EAF2
18        CD1C
19      RABEP2
20    TNFRSF17
21     RPL22L1
22        IRF8
23       CEPT1
24        NT5C
Name: names, dtype: object
</code></pre><h3 id="using-the-enrichr-module-for-querying-enrichr-libraries">Using the Enrichr Module for querying Enrichr libraries<a hidden class="anchor" aria-hidden="true" href="#using-the-enrichr-module-for-querying-enrichr-libraries">#</a></h3>
<p>Now that we have our list of marker genes for each Leiden cluster, we can use <code>clustermolepy</code>&rsquo;s built-in <code>Enrichr</code> module to directly query the Enrichr API! This makes it super easy to get biological insights from our marker genes.</p>
<p><code>clustermolepy</code> provides the <code>get_cell_type_enrichment()</code> method!  This handy function simplifies the process by automatically querying a curated set of Enrichr libraries that are specifically relevant for cell type identification.</p>
<p>Under the hood, <code>get_cell_type_enrichment()</code> is multi-threaded, making it efficient forquerying multiple gene sets efficently.  It automatically checks your marker genes against these ten key gene set libraries:</p>
<pre tabindex="0"><code>* CellMarker_2024
* CellMarker_Augmented_2021
* Descartes_Cell_Types_and_Tissue_2021
* PanglaoDB_Augmented_2021
* Azimuth_Cell_Types_2021
* Azimuth_2023
* Tabula_Sapiens
* Human_Gene_Atlas
* Tabula_Muris
* Mouse_Gene_Atlas
</code></pre><p>Using <code>get_cell_type_enrichment()</code> is incredibly straightforward. Using this with our Leiden Cluster 1 marker genes:</p>
<p><strong>Code:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>enrichr <span style="color:#f92672">=</span> Enrichr(list(b_cell_markers), adj_pval_cutoff<span style="color:#f92672">=</span><span style="color:#ae81ff">0.05</span>)
</span></span><span style="display:flex;"><span>enrichr<span style="color:#f92672">.</span>get_cell_type_enrichment()<span style="color:#f92672">.</span>head()
</span></span></code></pre></div><p><strong>Output</strong>:</p>
<pre tabindex="0"><code>             term name       p-value   odds ratio  combined score                                                                                    overlapping genes  adjusted p-value  old p-value  old adjusted p-value                   gene_set
0        B cell:Kidney  5.086026e-18   103.437309     4118.877258  [SMIM14, EAF2, CD79B, CD79A, TCL1A, RABEP2, MZB1, TNFRSF17, IRF8, CD37, RPL22L1, LTB, CEPT1, MS4A1]      8.544523e-16            0                     0  CellMarker_Augmented_2021
1  B Cell Kidney Human  4.980387e-18   103.601072     4127.572795  [SMIM14, EAF2, CD79B, CD79A, TCL1A, RABEP2, MZB1, TNFRSF17, IRF8, CD37, RPL22L1, LTB, CEPT1, MS4A1]      9.213717e-16            0                     0            CellMarker_2024
2    B Cell Lung Human  1.924020e-16  1664.666667    60239.200656                                                         [CD79B, CD79A, TCL1A, MZB1, TNFRSF17, MS4A1]      1.779719e-14            0                     0            CellMarker_2024
3        B Cells Naive  2.872640e-15   139.718310     4678.264291                                            [CD79B, CD79A, TCL1A, EAF2, IRF8, CD37, LTB, CD1C, MS4A1]      2.872640e-14            0                     0   PanglaoDB_Augmented_2021
4       B Cells Memory  2.244502e-15   143.797101     4850.318315                                        [CD79B, CD79A, TCL1A, TNFRSF17, IRF8, CD37, LTB, CD1C, MS4A1]      2.872640e-14            0                     0   PanglaoDB_Augmented_2021
</code></pre><hr>
<h2 id="how-does-enrichment-work">How Does Enrichment Work?<a hidden class="anchor" aria-hidden="true" href="#how-does-enrichment-work">#</a></h2>
<p>It’s worth briefly mentioning how the enrichment is actually calculated under the hood. At the core of this is a statistical test that checks whether your list of marker genes overlaps with known cell type–specific gene sets more than you&rsquo;d expect by random chance.</p>
<p>This is done using <a href="https://en.wikipedia.org/wiki/Fisher%27s_exact_test">Fisher’s exact test</a>, which builds a simple 2×2 contingency table like this:</p>
<p><img alt="Contingency Table" loading="lazy" src="/posts/clustermolepy/fisher_excat_test.png"></p>
<p>From this table, Fisher&rsquo;s Exact Test is used to calculate a p-value; basically asking: If I randomly picked genes, what&rsquo;s the chance I’d see this much overlap?</p>
<p>Here&rsquo;s the formula behind it:</p>
$$
p = \frac{{\binom{a + b}{a} \binom{c + d}{c}}}{{\binom{N}{a + c}}}
$$<hr>
<h2 id="extra-utilities">Extra Utilities<a hidden class="anchor" aria-hidden="true" href="#extra-utilities">#</a></h2>
<p>Beyond just sending your marker genes to Enrichr, clustermolepy comes with a couple of neat utilities that make your life easier when working with gene sets.</p>
<h3 id="fuzzy-matching-for-enrichr-libraries">Fuzzy Matching for Enrichr Libraries<a hidden class="anchor" aria-hidden="true" href="#fuzzy-matching-for-enrichr-libraries">#</a></h3>
<p>If you&rsquo;ve ever used the Enrichr web interface, you know how long list of libraries are. <code>clustermolepy</code> adds a small but super helpful feature: fuzzy matching for library names. So if you forget whether it&rsquo;s called <code>&quot;CellMarker_2024&quot;</code> or <code>&quot;cell_marker_human_2023&quot;</code>, you can just pass a partial name and let the fuzzy match do the work:</p>
<p><strong>Code:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>enrichr<span style="color:#f92672">.</span>get_libraries(name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;cellmarker&#34;</span>)  <span style="color:#75715e"># fuzzy search!</span>
</span></span></code></pre></div><p><strong>Output:</strong></p>
<pre tabindex="0"><code>    geneCoverage  genesPerTerm                libraryName                                         link  numTerms  categoryId
0         14167          80.0  CellMarker_Augmented_2021        http://biocc.hrbmu.edu.cn/CellMarker/      1097           5
1         12642          30.0            CellMarker_2024  http://bio-bigdata.hrbmu.edu.cn/CellMarker/      1692           5
</code></pre><h3 id="gene-name-conversion-via-biomart">Gene Name Conversion via Biomart<a hidden class="anchor" aria-hidden="true" href="#gene-name-conversion-via-biomart">#</a></h3>
<p><code>clustermolepy</code> also provides a convenient way to convert gene symbols between different species using the <code>biomart</code> module. This is particularly useful when you want to compare gene sets or perform enrichment analysis across different organisms.
In this example, we&rsquo;ll convert human gene symbols to mouse gene symbols using the <code>biomart</code> module. We&rsquo;ll use the <code>convert_gene_names()</code> function to fetch the gene conversion data and then apply it to our list of human genes.</p>
<p><strong>Code</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> clustermolepy.utils <span style="color:#f92672">import</span> Biomart
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Convert gene names from human to mouse</span>
</span></span><span style="display:flex;"><span>bm <span style="color:#f92672">=</span> Biomart(verbose<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>result <span style="color:#f92672">=</span> bm<span style="color:#f92672">.</span>convert_gene_names(
</span></span><span style="display:flex;"><span>    genes<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#34;TP53&#34;</span>, <span style="color:#e6db74">&#34;CD4&#34;</span>, <span style="color:#e6db74">&#34;FOXP3&#34;</span>], <span style="color:#75715e"># Example gene names</span>
</span></span><span style="display:flex;"><span>    from_organism<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;hsapiens&#34;</span>, <span style="color:#75715e"># Human</span>
</span></span><span style="display:flex;"><span>    to_organism<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;mmusculus&#34;</span> <span style="color:#75715e"># Mouse</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>print(result)
</span></span></code></pre></div><p><strong>Output</strong>:</p>
<pre tabindex="0"><code>{&#39;CD4&#39;: [&#39;Cd4&#39;], &#39;FOXP3&#39;: [&#39;Foxp3&#39;], &#39;TP53&#39;: [&#39;Trp53&#39;]}
</code></pre>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://nmlakra.github.io/tags/single-cell/">Single-Cell</a></li>
      <li><a href="http://nmlakra.github.io/tags/python/">Python</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://nmlakra.github.io/">Nikhil Mark Lakra</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
